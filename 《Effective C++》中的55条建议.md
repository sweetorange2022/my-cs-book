# 《Effective C++》中的55条建议，以及它们的具体做法：
<br>

## 第一部分：让自己适应C++
<br>
<br>
<br>
### 1. 视C++为一个语言联邦
<br>
   C++支持多种编程风格和语言特性，包括过程化编程、面向对象编程和泛型编程。为了编写高效、健壮和易于维护的代码，程序员需要深入了解每种编程风格和特性，并在需要时正确地应用它们。

###  2. 尽量以const、enum、inline替换#define
<br>
   在C++中，const对象具有类型，可以进行类型检查，并且可以放入诸如容器之类的标准库中。而#define宏定义则不具备这些优点，并且容易引起问题。因此，应该尽量使用const、enum和inline来替换#define。

### 3. 尽可能使用const
<br>
   在C++中，使用const可以帮助程序员识别出意图不改变变量值的代码，并帮助编译器执行优化。因此，在编写C++代码时，应该尽可能使用const。

### 4. 确定对象被使用前已先被初始化
<br>
   在C++中，必须确保对象在使用前已先被初始化，否则会导致未定义的行为。因此，程序员应该使用构造函数来初始化对象，或者使用C++11引入的初始化列表语法。

## 第二部分：构造、析构和赋值运算
<br>
<br>
<br>
### 5. 了解C++默认编写和调用哪些函数
<br>
   在C++中，编译器会自动生成默认的构造函数、拷贝构造函数、拷贝赋值运算符和析构函数，程序员需要了解它们的默认行为，以便避免不必要的编写和调用。

### 6. 若不想使用编译器自动生成的函数，就该明确拒绝
<br>
   如果程序员不想使用编译器自动生成的默认函数，则应该明确拒绝它们。这可以通过将这些函数声明为私有的并不进行实现来实现，或者使用C++11引入的delete关键字。

### 7. 为多态基类声明virtual析构函数
<br>
   如果一个类可能被作为多态基类使用，则应该为它声明一个虚析构函数。这样做可以保证在删除基类指针时，派生类的析构函数被正确地调用。

### 8. 别让异常逃离析构函数
<br>
   在析构函数中抛出异常会导致程序出现未定义的行为。因此，在编写析构函数时，应该尽可能避免抛出异常，或者在析构函数中使用try-catch语句捕获异常并处理它们。

### 9. 使用析构函数而非delete成员函数来释放动态内存
<br>
   在C++中，可以使用new操作符来动态分配内存，但是这样的内存必须手动释放。为了避免内存泄漏和二次释放，应该在析构函数中使用delete操作符来释放动态分配的内存。

### 10. 在operator=中处理自我赋值  
<br>
   在实现自定义类型的赋值运算符时，应该考虑自我赋值的情况，并采取措施避免出现问题。一种常见的方法是使用“copy and swap”技巧。

### 11. 复制对象时勿忘其每一个成分
<br>
   在实现自定义类型的拷贝构造函数和赋值运算符时，应该复制对象的每一个成分，包括基类成分和成员对象。

### 12. 复制对象时别忘了处理自我赋值
<br>
 在实现自定义类型的拷贝构造函数和赋值运算符时，应该处理自我赋值的情况，避免出现未定义的行为。一种常见的方法是使用“copy and swap”技巧。
 
## 第三部分：资源管理
<br>
<br>
<br>
### 13. 使用对象管理资源  
<br>
在使用对象来管理动态分配的内存、文件句柄等资源

###  14. 在资源管理类中小心copying行为
<br>
在实现资源管理类时，应该小心copying行为，以避免资源的多次释放或使用。一种常见的方法是禁止复制。

### 15. 在资源管理类中提供对原始资源的访问
<br>
在实现资源管理类时，应该提供对原始资源的访问，以便程序员能够使用诸如STL算法之类的标准库函数。


### 16. 成对使用new和delete时要采取相同形式
<br>
new和delete要使用相同的形式，包括使用[]运算符时也要如此。

### 17. 以独立语句将newed对象置入智能指针
<br>
使用独立语句将newed对象置入智能指针，以避免出现内存泄漏等问题。

## 四、设计与声明
<br>
<br>
<br>
###  18. 让接口容易被正确使用，不易被误用
<br>
在设计类的接口时，应该尽可能使其容易被正确使用，不易被误用。这可以通过提供清晰的文档、使用类型安全的接口、限制用户的访问权限等方式实现。

###  19. 设计class犹如设计type
<br>
 在设计class时，应该将其视为一个新的类型，并遵循类型设计的规则和原则，例如使用私有成员和公有成员、提供友元和成员函数等。

###  20. 宁以pass-by-reference-to-const替换pass-by-value
<br>
    在设计函数接口时，应该尽量使用引用传参而非值传参，以避免不必要的对象拷贝。同时，应该使用const修饰引用参数，以避免对参数的修改。

###  21. 必须返回对象时，不要试图返回一个reference
<br>
在设计函数接口时，应该避免返回局部变量或临时变量的引用，以避免访问非法内存。如果必须返回对象，则应该返回值而非引用。

### 22. 将成员变量声明为private
<br>
在设计class时，应该将成员变量声明为private，以封装实现细节，避免外部直接访问和修改。

###  23. 宁以non-member、non-friend替换member函数
<br>
在设计class时，应该尽量将函数实现为non-member和non-friend函数，以避免破坏封装性和增加耦合度。

### 24. 若所有参数皆需类型转换，请为此采用non-member函数
<br>
 在设计class时，如果需要进行类型转换，应该尽量使用non-member函数而非member函数，以避免破坏封装性和增加耦合度。

### 25. 考虑写出一个不抛异常的swap函数
<br>

在设计class时，应该考虑写出一个不抛异常的swap函数，以避免在交换对象时出现异常导致程序终止。
<br>

## 五、实现
<br>
<br>
<br>
### 26. 尽可能延后变量定义式的出现时间
<br>
   在编写代码时，应该尽可能延后变量定义式的出现时间，以避免不必要的构造和析构。

### 27. 尽量少做转型动作
<br>
    在编写代码时，应该尽量少做转型动作，避免类型不安全和难以维护。

### 28. 避免返回handles指向对象内部
<br>
    在设计class时，应该避免返回指向对象内部的handles，以避免破坏封装性和导致未定义的行为。

### 29. 为“异常安全”而努力是值得的
<br>
    在编写代码时，应该努力保证“异常安全”，以避免在异常情况下导致资源泄漏和程序崩溃。

### 30. 透彻理解inlining的里里外外
<br>
    在编写代码时，应该透彻理解inlining的实现细节和影响，以便正确地使用和避免误用。


### 31. 将文件间的编译依存关系降至最低
<br>
    在设计代码时，应该尽可能降低文件间的编译依存关系，以提高代码的可维护性和可复用性。
<br>

## 六、继承和面向对象设计

### 32. 确定你的public继承塑模出is-a关系
<br>
    在设计class时，应该确保public继承塑模出is-a关系，即子类对象也是父类对象，而非简单的共享实现细节。

### 33. 避免遮掩继承而来的名称
<br>
    在使用继承时，应该避免在子类中定义与父类相同的名称，以避免遮掩继承而来的名称。

### 34. 区分接口继承和实现继承
<br>
    在设计继承关系时，应该区分接口继承和实现继承，避免将实现细节暴露给子类。

### 35. 考虑virtual函数以外的其他选择
<br>
    在设计多态性时，应该考虑除了virtual函数以外的其他选择，如函数对象、模板等。

### 36. 绝不重新定义继承而来的non-virtual函数
<br>
    在设计class时，绝不能重新定义继承而来的non-virtual函数，以避免导致未定义的行为。

### 37. 绝不重新定义继承而来的缺省参数值
<br>
    在设计class时，绝不能重新定义继承而来的缺省参数值，以避免导致未定义的行为。

### 38. 通过复合塑模出has-a或“根据某物实现出”
<br>
    在设计class时，应该通过复合来塑模出has-a或“根据某物实现出”的关系，以避免过度依赖继承。

### 39. 明智而审慎地使用private继承
<br>
    在设计class时，应该明智而审慎地使用private继承，以避免破坏is-a关系和增加耦合度。

### 40. 明智而审慎地使用多重继承
<br>
    在设计class时，应该明智而审慎地使用多重继承，以避免复杂性和潜在的二义性。

## 七、模板和泛型编程

### 41. 了解隐式接口和编译器生成的函数
<br>
    了解编译器生成的函数和隐式接口，以确保程序的正确性和可读性。

### 42. 了解typename的双重意义
<br>
    在编写代码时，应该了解typename的双重意义和作用，以避免出现编译错误和歧义。

### 43. 学习处理模板化基类内的名称
<br>
  学习处理模板化基类内的名称意味着要掌握基类内的类型、函数和变量等名称在子类中的具体作用和用法，以便正确使用并防止名称冲突。

### 44. 将与参数无关的代码抽离templates模板
<br>
    在编写模板时，应该尽可能将与参数无关的代码抽离出来，以提高可复用性和编译速度。

### 45. 使用成员函数模板接受所有兼容类型
<br>
    在设计class时，应该使用成员函数模板来接受所有兼容类型，以提高代码的灵活性和可复用性。

### 46. 需要类型转换时请为模板定义非成员函数
<br>
    为需要类型转换的函数定义非成员函数，以保证代码的一致性和可读性。

### 47. 请使用traits classes表现类型信息
<br>
使用traits classes表现类型信息，以避免在编译时或运行时产生不必要的错误。

### 48. 认识template元编程
<br>
    在使用模板时，应该认识template元编程的思想和方法，以提高代码的灵活性和可复用性。

## 八、定制new和delete
<br>
<br>
<br>
### 49. 了解new-handler的行为
<br>
    在使用new时，应该了解new-handler的行为和作用，以提高程序的健壮性和可维护性。

### 50. 了解 new 和 delete 的合理替换时机
<br>
   当需要自定义内存分配算法时，可以替换默认的内存分配操作符。当需要更好地控制对象的构造和析构顺序时，可以替换默认的内存分配和释放操作符。当需要跟踪内存使用情况时，可以替换默认的内存分配和释放操作符。

### 51. 编写 new 和 delete 时需固守常规
<br>
    在重载类的 new 和 delete 运算符时要遵循常规，并了解其行为。

### 52. 写了placement new 也要写placement delete
<br>
    在使用 placement new 时，我们需要提供 new 操作符和必要的参数，以便在对象被分配到位置时提供有效的操作。然后，我们需要使用 placement delete 来释放该位置，以确保对象在堆上的正确位置被释放。

## 九、杂项讨论
<br>
<br>
<br>
### 53. 不要轻忽编译器的警告
<br>
    编译器可以帮助开发人员检测代码中的潜在问题。忽略编译器警告可能会导致软件质量和稳定性问题，因此应该尽可能地避免产生警告，并对警告进行适当的处理。
### 54. 让自己熟悉包括TRI在内的标准编译库
<br>
    熟悉C++标准库和TR1对于C++开发者来说非常重要，可以提高代码的效率和可读性。

### 55. 让自己熟悉标Boot
<br>
    Boost是一个开源的C++库集合，它包含了大量的高质量的C++库，覆盖了从基础工具到高级特性的各个领域，如容器、算法、函数对象、元编程、文件系统、智能指针、网络编程等等。
