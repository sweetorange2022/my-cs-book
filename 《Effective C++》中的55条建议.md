# Effective C++中的55条建议（笔记），以及它们的具体做法：
<br>

## 第一部分：让自己适应C++

### 1. 视C++为一个语言联邦
<br>
   C++支持多种编程风格和语言特性，包括过程化编程、面向对象编程和泛型编程。为了编写高效、健壮和易于维护的代码，程序员需要深入了解每种编程风格和特性，并在需要时正确地应用它们。

###  2. 尽量以const、enum、inline替换#define
<br>
   在C++中，const对象具有类型，可以进行类型检查，并且可以放入诸如容器之类的标准库中。而#define宏定义则不具备这些优点，并且容易引起问题。因此，应该尽量使用const、enum和inline来替换#define。

### 3. 尽可能使用const
<br>
   在C++中，使用const可以帮助程序员识别出意图不改变变量值的代码，并帮助编译器执行优化。因此，在编写C++代码时，应该尽可能使用const。

### 4. 确定对象被使用前已先被初始化
<br>
   在C++中，必须确保对象在使用前已先被初始化，否则会导致未定义的行为。因此，程序员应该使用构造函数来初始化对象，或者使用C++11引入的初始化列表语法。

## 第二部分：构造、析构和赋值运算

### 5. 了解C++默认编写和调用哪些函数
<br>
   在C++中，编译器会自动生成默认的构造函数、拷贝构造函数、拷贝赋值运算符和析构函数，程序员需要了解它们的默认行为，以便避免不必要的编写和调用。

### 6. 若不想使用编译器自动生成的函数，就该明确拒绝
<br>
   如果程序员不想使用编译器自动生成的默认函数，则应该明确拒绝它们。这可以通过将这些函数声明为私有的并不进行实现来实现，或者使用C++11引入的delete关键字。

### 7. 为多态基类声明virtual析构函数
<br>
   如果一个类可能被作为多态基类使用，则应该为它声明一个虚析构函数。这样做可以保证在删除基类指针时，派生类的析构函数被正确地调用。

### 8. 别让异常逃离析构函数
<br>
   在析构函数中抛出异常会导致程序出现未定义的行为。因此，在编写析构函数时，应该尽可能避免抛出异常，或者在析构函数中使用try-catch语句捕获异常并处理它们。

### 9. 使用析构函数而非delete成员函数来释放动态内存
<br>
   在C++中，可以使用new操作符来动态分配内存，但是这样的内存必须手动释放。为了避免内存泄漏和二次释放，应该在析构函数中使用delete操作符来释放动态分配的内存。

### 10. 在operator=中处理自我赋值  
<br>
   在实现自定义类型的赋值运算符时，应该考虑自我赋值的情况，并采取措施避免出现问题。一种常见的方法是使用“copy and swap”技巧。

### 11. 复制对象时勿忘其每一个成分
<br>
   在实现自定义类型的拷贝构造函数和赋值运算符时，应该复制对象的每一个成分，包括基类成分和成员对象。

### 12. 复制对象时别忘了处理自我赋值
<br>
 在实现自定义类型的拷贝构造函数和赋值运算符时，应该处理自我赋值的情况，避免出现未定义的行为。一种常见的方法是使用“copy and swap”技巧。

### 13. 使用对象的引用来实现赋值运算符  
<br>
在实现自定义类型的赋值运算符时，应该使用对象的引用来避免不必要的对象拷贝。同时，应该确保正确处理自我赋值的情况。

###  14. 在资源管理类中小心copying行为
<br>
在实现资源管理类时，应该小心copying行为，以避免资源的多次释放或使用。一种常见的方法是禁止复制。

### 15. 在资源管理类中提供对原始资源的访问
<br>
在实现资源管理类时，应该提供对原始资源的访问，以便程序员能够使用诸如STL算法之类的标准库函数。

## 第三部分：资源管理

### 16. 使用RAII管理资源
<br>
在C++中，可以使用RAII(Resource Acquisition Is Initialization)技术来管理资源，这可以避免资源泄漏和二次释放等问题。

### 17. 在构造函数中使用try-catch语句捕获异常
<br>
在使用RAII技术管理资源时，应该在构造函数中使用try-catch语句捕获异常，并在捕获到异常时正确地处理资源。

###  18. 让接口容易被正确使用，不易被误用
<br>
在设计类的接口时，应该尽可能使其容易被正确使用，不易被误用。这可以通过提供清晰的文档、使用类型安全的接口、限制用户的访问权限等方式实现。

###  19. 设计class犹如设计type
<br>
 在设计class时，应该将其视为一个新的类型，并遵循类型设计的规则和原则，例如使用私有成员和公有成员、提供友元和成员函数等。

###  20. 宁以pass-by-reference-to-const替换pass-by-value
<br>
    在设计函数接口时，应该尽量使用引用传参而非值传参，以避免不必要的对象拷贝。同时，应该使用const修饰引用参数，以避免对参数的修改。

###  21. 必须返回对象时，不要试图返回一个reference
<br>
在设计函数接口时，应该避免返回局部变量或临时变量的引用，以避免访问非法内存。如果必须返回对象，则应该返回值而非引用。

### 22. 将成员变量声明为private
<br>
在设计class时，应该将成员变量声明为private，以封装实现细节，避免外部直接访问和修改。

###  23. 宁以non-member、non-friend替换member函数
<br>
在设计class时，应该尽量将函数实现为non-member和non-friend函数，以避免破坏封装性和增加耦合度。

### 24. 若所有参数皆需类型转换，请为此采用non-member函数
<br>
 在设计class时，如果需要进行类型转换，应该尽量使用non-member函数而非member函数，以避免破坏封装性和增加耦合度。

### 25. 考虑写出一个不抛异常的swap函数
<br>

在设计class时，应该考虑写出一个不抛异常的swap函数，以避免在交换对象时出现异常导致程序终止。

### 26. 尽可能延后变量定义式的出现时间
<br>
   在编写代码时，应该尽可能延后变量定义式的出现时间，以避免不必要的构造和析构。

### 27. 尽量少做转型动作
<br>
    在编写代码时，应该尽量少做转型动作，避免类型不安全和难以维护。

### 28. 避免返回handles指向对象内部
<br>
    在设计class时，应该避免返回指向对象内部的handles，以避免破坏封装性和导致未定义的行为。

### 29. 为“异常安全”而努力是值得的
<br>
    在编写代码时，应该努力保证“异常安全”，以避免在异常情况下导致资源泄漏和程序崩溃。

### 30. 透彻理解inlining的里里外外
<br>
    在编写代码时，应该透彻理解inlining的实现细节和影响，以便正确地使用和避免误用。

## 第四部分：设计与声明

### 31. 将文件间的编译依存关系降至最低
<br>
    在设计代码时，应该尽可能降低文件间的编译依存关系，以提高代码的可维护性和可复用性。

### 32. 确定你的public继承塑模出is-a关系
<br>
    在设计class时，应该确保public继承塑模出is-a关系，即子类对象也是父类对象，而非简单的共享实现细节。

### 33. 避免遮掩继承而来的名称
<br>
    在使用继承时，应该避免在子类中定义与父类相同的名称，以避免遮掩继承而来的名称。

### 34. 区分接口继承和实现继承
<br>
    在设计继承关系时，应该区分接口继承和实现继承，避免将实现细节暴露给子类。

### 35. 考虑virtual函数以外的其他选择
<br>
    在设计多态性时，应该考虑除了virtual函数以外的其他选择，如函数对象、模板等。

### 36. 绝不重新定义继承而来的non-virtual函数
<br>
    在设计class时，绝不能重新定义继承而来的non-virtual函数，以避免导致未定义的行为。

### 37. 绝不重新定义继承而来的缺省参数值
<br>
    在设计class时，绝不能重新定义继承而来的缺省参数值，以避免导致未定义的行为。

### 38. 通过复合塑模出has-a或“根据某物实现出”
<br>
    在设计class时，应该通过复合来塑模出has-a或“根据某物实现出”的关系，以避免过度依赖继承。

### 39. 明智而审慎地使用private继承
<br>
    在设计class时，应该明智而审慎地使用private继承，以避免破坏is-a关系和增加耦合度。

### 40. 明智而审慎地使用多重继承
<br>
    在设计class时，应该明智而审慎地使用多重继承，以避免复杂性和潜在的二义性。

### 41. 了解隐式接口和编译器的党派
<br>
    在设计class时，应该了解隐式接口和编译器的党派，以避免出现不必要的依赖和限制。

### 42. 了解typename的双重意义
<br>
    在编写代码时，应该了解typename的双重意义和作用，以避免出现编译错误和歧义。

### 43. 学习处理模板化基类内的名称
<br>
  学习处理模板化基类内的名称意味着要掌握基类内的类型、函数和变量等名称在子类中的具体作用和用法，以便正确使用并防止名称冲突。

### 44. 将与参数无关的代码抽离模板
<br>
    在编写模板时，应该尽可能将与参数无关的代码抽离出来，以提高可复用性和编译速度。

### 45. 使用成员函数模板接受所有兼容类型
<br>
    在设计class时，应该使用成员函数模板来接受所有兼容类型，以提高代码的灵活性和可复用性。

### 46. 需要类型转换时请使用显式方法
<br>
    在进行类型转换时，应该使用显式的方法，如static_cast、dynamic_cast等，以避免不必要的隐式类型转换。

### 47. 确保非类型模板参数有意义
<br>
    在使用非类型模板参数时，应该确保其具有实际意义，并且不会对程序的可移植性造成影响。

### 48. 认识template元编程
<br>
    在使用模板时，应该认识template元编程的思想和方法，以提高代码的灵活性和可复用性。

### 49. 了解new-handler的行为
<br>
    在使用new时，应该了解new-handler的行为和作用，以提高程序的健壮性和可维护性。

### 50. 理解auto和decltype的作用
<br>
    在使用C++11的新特性时，应该理解auto和decltype的作用和用法，以提高代码的简洁性和可读性。

### 51. 熟悉Lambda表达式
<br>
    在使用C++11的新特性时，应该熟悉Lambda表达式的语法和用法，以提高代码的灵活性和可读性。

### 52. 理解std::move和std::forward
<br>
    在使用C++11的新特性时，应该理解std::move和std::forward的作用和用法，以提高代码的效率和可维护性。

### 53. 熟悉可变参数模板
<br>
    在使用C++11的新特性时，应该熟悉可变参数模板的语法和用法，以提高代码的灵活性和可读性。

### 54. 使用别名和typedef简化复杂类型
<br>
    在编写代码时，应该使用别名和typedef来简化复杂类型的声明和使用，以提高代码的可读性和可维护性。

### 55. 熟悉标准库
<br>
    在编写代码时，应该熟悉C++标准库提供的容器、算法、迭代器等组件，以提高代码的效率和可维护性。
